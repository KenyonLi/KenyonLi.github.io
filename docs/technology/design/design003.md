---
title: '存储高可用'
date: '2024-03-29' 
tags:
- '数据库设计'
- 'redis'
- 'dotn'
- 'mysql'
categories:
- '技术'
---

## 目录
[[toc]]


## 存储高可用
## 数据库可用文案：数据库高可用文案： redis  mysql  mongodb consul,sqlserver

Hbase
Hadoop
MongoDB
Mysql-cluster

1、主备方案：数据量小，并发量小。
2、主从方案：数据量小，读并发里大，写并发量小。
3、主主方案：数据量小，读并发量小，写并发量大。
4、主从集群方案：数据量小，读并发量非常大，写并发量小。
5、集群分散方案：数据量大（大数库），读并发量大，写并发量大。

## 数据分区高可用
1. 互相备份方案：数据量不大，经济上不富裕
2. 集中式方案：数据量不大，经济富裕。
3. 独立式方案：数据量非常（大数据）。经济非常富裕。

### 如何实现这些方案
1. Mysql :Canal
2. SqlServer Oracel :DataX


## 计算高可用

1、计算高可用
计算：处理客户请求
无论什么情况下，都不会宕机
简单一句话：就是系统高可用。

对称计算。电商系统，所有实例都是相同的
### 主备
数据并发量小只有一个实例
### 主从
数据并发量小，有两个实例
### 对称集群 
数据并发量大，N个实现

### 对称集群 -伸缩/动态架构
数据并发量小、大。N个实现

consul-Template


### 非对称高可用

 
1、非对称计算：Nginx
 系统计算不一样。不一样的客户请求
 读并发量大，写并发量小

 1、主从：写数据并发量小，读数据并发量小
 2、非对称集群：写数据并发量小，读数据并发量大
 3、非对称集群-动态架构：写数据并发量小，读数据并发量小、大。

 任何系统中，数据。
 扩展：
 1. 如果写数据并发量大，读数据并发里大。
 2. 非对称集群-动态架构-分散集群

 总结：
 1、 计算高可用
  1. 对称计算高可用。实例处理客户端请求一样。
  2. 非对称计算高可用。实例处理客户端请求不一样。

2、扩展方面
 
 对称集群：不存储客户端数据的
 非对称集群：存储客户端数据的
 1. redis集群    非对称
 2. mongodb集群  非对称
 3. nginx集群    对称
 4. 电商网系统    对称
 5. docker集群   非对称
 6. k8s 集群     非对称
 

 1. 如果nginx对称集群---电商系统架构思路一样
 2. 如果docker非对称集群----Mysql-Cluster

1. 计算高可用
2. 存储高可用
3. 计算高性能
4. 存储高性能

## 业务高可用
什么是业务高用
任何时候，保证业务能够正常访问
 

同城备份架构： 缺陷：时间延时，系统体验下降 
1、业务操作实时性低：用户注册  行为

同城异区架构：
1、业务操作实时性强。用户登录  行为


跨城异地存在
总结
1、业务高可用，从系统整体角度思考
方案
1. 同城备份方案
2. 同城异区方案
3. 跨城异地方案
4. 跨国方案

1、从业务整体思考，业务系统高可用
2、业务接口角度思考，业务系统如何保证高可用？
客户端并发，并发操作了业务系统的最高处理能力！
1. 业务系统宕机
2. 业务不可用

解决方案：限流

无论系统部署到任何地方，资源是有限的
1. 并发能力有限

   单体限流：单体
   增加限流模块
   分布式限流：集群
   nginx OpenResty
   限流有一个局限
   1. 直接过滤了所有请求，拒绝过滤的请求。


   换一个前提
   1. 分布式系统。
   2. 资源有限。 
   进程内降级：将原有的系统变成不可访问
   独立降级
   总结：正常的系统变成不正常。目的腾出资源给核心系统使用。
     
    方案：熔断
    .netcore polly 
    ocelot  ocelot.polly.

    总结：
    1. 单体系统：限流、排队
    2. 分布式系统：降级、熔断;
     限流、排队（具体第一个分布系统高可用）

## 总结
1、 业务全局角度
  1. 同城备份方案
  2. 同城异区方案
  3. 跨城异地方案
  4. 跨国方案

2、 业务接口角度
  1. 单体系统：限流、排队
  2. 分布式系统：降级、熔断
  限流、排队（具体每一个分布式系统高可用）

