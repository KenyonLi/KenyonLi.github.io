---
title: '存储高可用'
date: '2024-03-29' 
tags:
- '数据库设计'
- 'redis'
- 'dotn'
- 'mysql'
categories:
- '技术'
---

## 目录
[[toc]]


## 存储高可用
## 数据库可用文案：数据库高可用文案： redis  mysql  mongodb consul,sqlserver

Hbase
Hadoop
MongoDB
Mysql-cluster

1、主备方案：数据量小，并发量小。
2、主从方案：数据量小，读并发里大，写并发量小。
3、主主方案：数据量小，读并发量小，写并发量大。
4、主从集群方案：数据量小，读并发量非常大，写并发量小。
5、集群分散方案：数据量大（大数库），读并发量大，写并发量大。

## 数据分区高可用
1. 互相备份方案：数据量不大，经济上不富裕
2. 集中式方案：数据量不大，经济富裕。
3. 独立式方案：数据量非常（大数据）。经济非常富裕。

### 如何实现这些方案
1. Mysql :Canal
2. SqlServer Oracel :DataX


## 计算高可用

1、计算高可用
计算：处理客户请求
无论什么情况下，都不会宕机
简单一句话：就是系统高可用。

对称计算。电商系统，所有实例都是相同的
### 主备
数据并发量小只有一个实例
### 主从
数据并发量小，有两个实例
### 对称集群 
数据并发量大，N个实现

### 对称集群 -伸缩/动态架构
数据并发量小、大。N个实现

consul-Template


### 非对称高可用

 
1、非对称计算：Nginx
 系统计算不一样。不一样的客户请求
 读并发量大，写并发量小

 1、主从：写数据并发量小，读数据并发量小
 2、非对称集群：写数据并发量小，读数据并发量大
 3、非对称集群-动态架构：写数据并发量小，读数据并发量小、大。

 任何系统中，数据。
 扩展：
 1. 如果写数据并发量大，读数据并发里大。
 2. 非对称集群-动态架构-分散集群

 总结：
 1、 计算高可用
  1. 对称计算高可用。实例处理客户端请求一样。
  2. 非对称计算高可用。实例处理客户端请求不一样。

2、扩展方面
 
 对称集群：不存储客户端数据的
 非对称集群：存储客户端数据的
 1. redis集群    非对称
 2. mongodb集群  非对称
 3. nginx集群    对称
 4. 电商网系统    对称
 5. docker集群   非对称
 6. k8s 集群     非对称
 

 1. 如果nginx对称集群---电商系统架构思路一样
 2. 如果docker非对称集群----Mysql-Cluster

1. 计算高可用
2. 存储高可用
3. 计算高性能
4. 存储高性能

## 业务高可用
什么是业务高用
任何时候，保证业务能够正常访问
 

同城备份架构： 缺陷：时间延时，系统体验下降 
1、业务操作实时性低：用户注册  行为

同城异区架构：
1、业务操作实时性强。用户登录  行为


跨城异地存在
总结
1、业务高可用，从系统整体角度思考
方案
1. 同城备份方案
2. 同城异区方案
3. 跨城异地方案
4. 跨国方案

1、从业务整体思考，业务系统高可用
2、业务接口角度思考，业务系统如何保证高可用？
客户端并发，并发操作了业务系统的最高处理能力！
1. 业务系统宕机
2. 业务不可用

解决方案：限流

无论系统部署到任何地方，资源是有限的
1. 并发能力有限

   单体限流：单体
   增加限流模块
   分布式限流：集群
   nginx OpenResty
   限流有一个局限
   1. 直接过滤了所有请求，拒绝过滤的请求。


   换一个前提
   1. 分布式系统。
   2. 资源有限。 
   进程内降级：将原有的系统变成不可访问
   独立降级
   总结：正常的系统变成不正常。目的腾出资源给核心系统使用。
     
    方案：熔断
    .netcore polly 
    ocelot  ocelot.polly.

    总结：
    1. 单体系统：限流、排队
    2. 分布式系统：降级、熔断;
     限流、排队（具体第一个分布系统高可用）

## 总结
1、 业务全局角度
  1. 同城备份方案
  2. 同城异区方案
  3. 跨城异地方案
  4. 跨国方案

2、 业务接口角度
  1. 单体系统：限流、排队
  2. 分布式系统：降级、熔断
  限流、排队（具体每一个分布式系统高可用）

## 高扩展架构

什么是扩展，自定义操作：如果不修改原有系统。
扩展好处：适应不同的客户需求。
         系统能够遵守开闭原则

什么是高扩展，原有系统不做任何改变 
系统中任何模块，都能实现扩展。所有模块总数加起来，就是高扩展。

如何将架构做成高扩展

架构===属于系统
系统架构如何得到？
拆分：
拆分好处：系统具备了扩展性。
1. 整体分解成部分。形成了架构，进一歩具备扩展性
怎么拆分？对谁拆分。系统。
对系统怎么拆分。  
系统：
  1. 流程：请求执行过程
  2. 模块：独立功能 + 数据
  3. 功能：业务逻辑


  ## 面向流程拆分
  什么是流程
  执行客户请求的过程
  添加商品
  1. 客户端---> 商品逻辑处理---> 商品数据处理---> 存储到数据库

  公司为例子：
  1. 老板是客户 
  2. 员工是服务
  用户--> 老板--> 管理-->一线员工（可以无限递归）
  客户端-->电商网站-->数据库

  1. 思想：客户+服务思想
  业务（客户请求）流程（经历的过程）：
  流程：根据每个角色独立拆分。
   

::: 1. 业务流程拆分：全局架构，布局思想
     1. 商品
     2. 用户
     3. 订单
     4. 支付
  2、 如何处理业务
  1. 先具体：把所有业务都具体流程写处理
  2. 后抽象： 从具体相同流程中。抽象概念（抽象就是顶级架构）
  3. 再把概念拆分
::: 

1. 面向流程拆分的架构，叫做分层架构
分层架构：
MVC分层架构：文件夹分层架构
只要你为别人服务，就会形成流程


文件夹分层架构前提：
   1、人少（1个人），系统模块多的时候
   2、人少了（1个人），系统模块少的时候
   架构意识---->扩展
   1、人多了，系统模块多的时候
   业务模块（服务）拆分：微服务架构
    面向功能拆分：插件架构（反射就可以实现）

   当我们数量过多了，我们要归类，形成流程（归纳流程）。使用流程来分类
   
   有流程存在，就用文件夹

   总结
   1. 面向流程
   2. 面向模块（服务）拆分
   3. 面向功能

   公司人多的时候，同时使用
   公司人少： 项目使用文件夹分层。
   系统模块少：使用，文件夹分层。
   客户需求少，文件夹分层
   系统模块更新频繁：
    1. 客户需求多，修改原有系统
    2. 客户端改变频繁

    解决方案：程序集拆分
    1.程序集分层----文件夹分层架构来源

    前提：客户端小。需求变化频繁
    如果客户数量变多了，需求也变化频繁
    程序集分层：DDD领域驱动,ABP


    总结：
    1. 文件夹分层架构。开发者角度，开发人少。业务模块数量，少/多的时候。客户数量少，客户需求量小
    2. 微服务架构：开发者角度，开发人多，业务模块数量，少/多的时候。
    3. 基础设施架构：开发者角度，开发人多，业务模块数量多，且通用功能少/多的时候
    4. 程序集分层架构：使用者（客户端角度），客户数量少,客户需求量大的时候。
    5. 程序集进一步分层---DDD：使用者（客户端角度），客户数量多（PC，App）,客户需求量大的时候
    总结：纵向扩展
    扩展
    1、 从并发量角度思考：如果客户端并发量大，集群架构。横向扩容即可。项目数量增加。
    总结：
    1. 系统最终：纵向 + 横向  。纵横技术---纵横四海
    前提：
    1. 开发者：多和少
    2. 使用者：多和少。大和小
    3. 课程：难和易，好和不好

    进一步：多和少。直觉，小和大。矛盾。
    进一步：思想的本质：矛盾（阴阳）
    毛主度：矛盾论

    高薪就业：
    1、天时：城市经济环境，起薪。
    2、地利：企业经济环境。开薪水。
    3、人和：人个技术实力
    每一个人薪水待遇，薪水理念

    高薪就业情况录取
    高薪就业情况分析
    高薪就业指导


1.城市:深圳
2.年龄:27
3.薪资:15K
4.学历:本科
5.专业:网络工程
6.毕业院校:桂林电子科技大学信息科技学院
7.工作经验:5年
8.短期诉求:18K以上薪资，使用技术较新
9.最近一次工作多长时间:1年

