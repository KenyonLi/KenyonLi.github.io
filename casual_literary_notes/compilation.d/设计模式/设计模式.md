## 设计模式简介

### 创建型模式（Creational Patterns）：

#### 工厂方法模式（Factory Method Pattern）：

* 优势：将对象的创建与使用分离，使得系统更加灵活，易于扩展。
* 劣势：需要创建具体的工厂类，增加了系统的复杂度。
* 应用场景：当对象的创建过程比较复杂，需要根据不同条件创建不同对象时使用。

#### 抽象工厂模式（Abstract Factory Pattern）：

* 优势：能够创建一系列相关或相互依赖的对象，提供了一种高层次的抽象接口。

* 劣势：新增产品族或产品等级结构时，需要修改抽象工厂接口，影响系统的灵活性。

* 应用场景：适用于产品族和产品等级结构比较固定，需要进行扩展时。

### 单例模式（Singleton Pattern）：

优势：确保一个类只有一个实例，节省系统资源，提高性能。
劣势：可能会引起多线程访问安全问题，需要考虑线程安全。
应用场景：适用于需要全局唯一实例的情况，如配置管理、日志记录等。
### 建造者模式（Builder Pattern）：

优势：将复杂对象的构建过程分解成多个步骤，使得构建过程更加灵活，易于理解和维护。
劣势：需要创建多个建造者类，增加了系统的复杂度。
应用场景：当对象的构建过程比较复杂，需要分步骤构建时使用。
### 原型模式（Prototype Pattern）：

优势：通过复制现有对象来创建新对象，避免了创建过程中的耗时操作。
劣势：可能会破坏对象的封装性，需要谨慎使用。
应用场景：适用于对象的创建成本较高、构造函数复杂或者需要频繁创建的情况。

### 结构型模式（Structural Patterns）：

#### 适配器模式（Adapter Pattern）：

* 优势：能够将不兼容的接口转换成可兼容的接口，提高了系统的灵活性和复用性。
* 劣势：可能会增加系统的复杂度，引入适配器类。
* 应用场景：适用于需要将现有接口适配成其他接口的情况。

#### 桥接模式（Bridge Pattern）：

* 优势：将抽象部分和实现部分分离，使得它们可以独立变化，提高了系统的灵活性。
* 劣势：增加了系统的复杂度，需要创建多个抽象和实现的类。
* 应用场景：适用于多维度变化的情况，例如操作系统和文件系统的组合。

#### 组合模式（Composite Pattern）：

* 优势：能够将对象组合成树形结构，使得客户端可以统一对待单个对象和组合对象。
* 劣势：可能会导致系统过度一般化，不适用于所有场景。
* 应用场景：适用于处理树形结构的情况，例如文件系统、组织架构等。

#### 装饰器模式（Decorator Pattern）：

* 优势：能够动态地给对象添加额外的功能，而不需要修改原始对象。
* 劣势：可能会引入大量的装饰器类，增加系统的复杂度。
* 应用场景：适用于需要灵活地扩展对象功能的情况，例如IO流、GUI组件等。

#### 外观模式（Facade Pattern）：

* 优势：为复杂子系统提供一个简单的接口，隐藏内部复杂性，降低了客户端与子系统之间的耦合度。
* 劣势：可能会导致外观类变得臃肿，需要注意设计。
* 应用场景：适用于需要对外提供简单接口，隐藏内部复杂逻辑的情况。

#### 享元模式（Flyweight Pattern）：

* 优势：通过共享对象来减少内存占用，提高了系统的性能。
* 劣势：可能会增加系统的复杂度，需要管理共享对象的生命周期。
* 应用场景：适用于存在大量相似对象，且对象可共享的情况。

#### 代理模式（Proxy Pattern）：

* 优势：能够控制对对象的访问，并在访问对象时添加额外的功能。
* 劣势：增加了系统的复杂度，引入了代理类。
* 应用场景：适用于需要控制对对象访问权限或者添加额外功能的情况。

## 行为型模式（Behavioral Patterns）

### 责任链模式（Chain of Responsibility Pattern）：

* 优势：将请求发送者和接收者解耦，使得请求可以被多个接收者处理，提高系统的灵活性和可扩展性。
* 劣势：可能会导致责任链过长，影响性能；不保证请求一定被处理，可能会出现请求无法被处理的情况。
* 应用场景：适用于存在多个处理者的情况，每个处理者都有能力处理请求但具体处理者未知的场景。

#### 命令模式（Command Pattern）：

* 优势：将请求发送者和接收者解耦，支持撤销和重做操作，以及对命令进行扩展和组合。
* 劣势：可能会导致命令类过多，增加系统复杂度；需要额外的命令管理类。
* 应用场景：适用于需要将请求封装成对象，支持撤销和重做操作的情况，例如菜单操作、遥控器按钮等。

#### 解释器模式（Interpreter Pattern）：

* 优势：定义了语言的文法，并提供了解释器来解释语言中的表达式，支持扩展新的表达式。
* 劣势：每个文法规则都需要创建一个解释器对象，可能会导致类的数量庞大。
* 应用场景：适用于需要解释语言或表达式的情况，例如编译器、正则表达式解析等。

#### 迭代器模式（Iterator Pattern）：

* 优势：提供了一种统一的方式来访问聚合对象中的各个元素，隐藏了聚合对象的内部结构。
* 劣势：可能会导致迭代器类过多，增加系统的复杂度。
* 应用场景：适用于需要遍历聚合对象的情况，例如集合类、树形结构等。

#### 中介者模式（Mediator Pattern）：

* 优势：将对象之间的交互集中在中介者对象中，降低了对象之间的耦合度，易于维护和扩展。
* 劣势：中介者对象可能会变得庞大，包含过多的交互逻辑。
* 应用场景：适用于对象之间存在复杂的交互关系，需要通过中介者来进行协调的情况。

#### 备忘录模式（Memento Pattern）：

* 优势：能够将对象的状态保存在备忘录中，支持恢复到之前的状态，不破坏封装性。
* 劣势：可能会消耗大量的内存，需要谨慎管理备忘录对象。
* 应用场景：适用于需要保存和恢复对象状态的情况，例如撤销操作、游戏存档等。

#### 观察者模式（Observer Pattern）：

* 优势：定义了一种一对多的依赖关系，当对象状态发生变化时，所有依赖于它的对象都会得到通知。
* 劣势：可能会导致观察者对象过多，增加系统的复杂度。
* 应用场景：适用于对象之间存在一对多的依赖关系，当一个对象的状态发生变化需要通知其他对象时使用。

#### 状态模式（State Pattern）：

* 优势：将对象的状态封装成独立的类，使得状态转换更加明确，易于扩展和维护。
* 劣势：可能会导致状态类过多，增加系统的复杂度。
* 应用场景：适用于对象的行为随状态的改变而改变的情况，例如状态机、流程控制等。

#### 策略模式（Strategy Pattern）：

* 优势：定义了一系列算法，并将每个算法封装成单独的类，使得算法可以独立于客户端而变化。
* 劣势：客户端需要知道所有的策略类，可能会增加系统的复杂度。
* 应用场景：适用于需要在多个算法中选择一种来使用的情况，例如排序算法、支付方式等。

#### 模板方法模式（Template Method Pattern）：

* 优势：定义了一个算法的骨架，将具体步骤延迟到子类实现，提高了代码的复用性。
* 劣势：可能会导致子类过多，增加系统的复杂度。
* 应用场景：适用于一些算法框架的情况，其中具体步骤可能会有所不同。

#### 访问者模式（Visitor Pattern）：

* 优势：将数据结构与数据操作分离，使得数据操作可以独立变化，易于扩展和维护。
* 劣势：可能会导致访问者类过多，增加系统的复杂度。
* 应用场景：适用于数据结构稳定而数据操作频繁变化的情况，例如编译器、解释器等。