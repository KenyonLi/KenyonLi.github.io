## 23种设计模式-优势和劣势，以及应用场景

设计模式通常分为三大类：创建型模式、结构型模式和行为型模式。以下是23种设计模式的详细分类、各自的优势和劣势，以及应用场景：

### 创建型模式

1. **单例模式 (Singleton)**
   - **优点**: 确保某一个类只有一个实例，节约系统资源。
   - **缺点**: 扩展性差，隐藏类依赖。
   - **应用场景**: 配置管理类、资源管理类、日志记录类。

2. **工厂方法模式 (Factory Method)**
   - **优点**: 解耦了具体产品的创建和使用，符合开放-关闭原则。
   - **缺点**: 增加了系统复杂性，每增加一种产品都需要增加一个具体工厂类。
   - **应用场景**: 日志记录器、数据库访问。

3. **抽象工厂模式 (Abstract Factory)**
   - **优点**: 符合开放-关闭原则，增加产品族方便。
   - **缺点**: 增加了系统复杂性，产品族扩展不方便。
   - **应用场景**: GUI工具包的跨平台支持。

4. **建造者模式 (Builder)**
   - **优点**: 使得建造代码和表示代码分离，简化对象的创建。
   - **缺点**: 产品必须有共同点，需求变化导致修改代价大。
   - **应用场景**: 复杂对象的创建，如文本解析器。

5. **原型模式 (Prototype)**
   - **优点**: 可以在运行时动态增加或减少产品，简化创建过程。
   - **缺点**: 每一个类都需要实现克隆方法，比较复杂。
   - **应用场景**: 资源优化的场合，避免重复的初始化操作。

### 结构型模式

1. **适配器模式 (Adapter)**
   - **优点**: 使得原本不兼容的接口可以一起工作。
   - **缺点**: 增加代码复杂性。
   - **应用场景**: 系统迁移，使用现有类而不修改源代码。

2. **桥接模式 (Bridge)**
   - **优点**: 分离抽象部分和实现部分，提高系统的可扩展性。
   - **缺点**: 增加了系统的复杂性。
   - **应用场景**: 图形系统和窗口系统的设计。

3. **组合模式 (Composite)**
   - **优点**: 使得客户端对单个对象和组合对象的使用具有一致性。
   - **缺点**: 设计较复杂。
   - **应用场景**: 文件系统，GUI组件。

4. **装饰模式 (Decorator)**
   - **优点**: 动态增加对象功能，比继承灵活。
   - **缺点**: 产生很多小对象，增加系统复杂性。
   - **应用场景**: GUI中为控件增加功能。

5. **外观模式 (Facade)**
   - **优点**: 为子系统中的一组接口提供一个一致的接口，简化客户端使用。
   - **缺点**: 不符合开闭原则，修改时可能影响其他代码。
   - **应用场景**: 图形界面设计，简化操作流程。

6. **享元模式 (Flyweight)**
   - **优点**: 减少创建对象的数量，节约内存。
   - **缺点**: 使得系统更复杂，需要额外的维护逻辑。
   - **应用场景**: 系统需要大量相似对象的场合，如字符处理。

7. **代理模式 (Proxy)**
   - **优点**: 控制访问对象，提供额外功能。
   - **缺点**: 增加了系统复杂性。
   - **应用场景**: 远程代理、虚代理、保护代理。

### 行为型模式

1. **责任链模式 (Chain of Responsibility)**
   - **优点**: 解耦请求发送者和接受者。
   - **缺点**: 请求不一定被处理。
   - **应用场景**: 事件处理系统，审批流程。

2. **命令模式 (Command)**
   - **优点**: 将请求封装为对象，支持撤销操作。
   - **缺点**: 增加系统复杂性。
   - **应用场景**: 事务系统，GUI中的按钮操作。

3. **解释器模式 (Interpreter)**
   - **优点**: 方便扩展新的解释器，灵活。
   - **缺点**: 执行效率较低，复杂性较高。
   - **应用场景**: 语言解释器，规则引擎。

4. **迭代器模式 (Iterator)**
   - **优点**: 提供一致的方法遍历各种集合，不需要了解集合的内部结构。
   - **缺点**: 增加了类的复杂性。
   - **应用场景**: 遍历集合对象，如数组和链表。

5. **中介者模式 (Mediator)**
   - **优点**: 降低对象之间的耦合，简化对象通信。
   - **缺点**: 中介者会变得复杂，难以维护。
   - **应用场景**: 图形界面设计，MVC模式中的控制器。

6. **备忘录模式 (Memento)**
   - **优点**: 保存对象的状态，支持撤销操作。
   - **缺点**: 占用更多内存。
   - **应用场景**: 需要保存历史记录的场合，如文本编辑器。

7. **观察者模式 (Observer)**
   - **优点**: 实现对象间的多对多依赖关系，支持广播通信。
   - **缺点**: 观察者多时，通知开销大。
   - **应用场景**: 事件系统，订阅发布模型。

8. **状态模式 (State)**
   - **优点**: 通过改变对象内部状态，改变对象行为。
   - **缺点**: 增加类的数目和复杂性。
   - **应用场景**: 状态机的实现，如TCP连接状态。

9. **策略模式 (Strategy)**
   - **优点**: 定义一系列算法，允许在运行时选择。
   - **缺点**: 客户端必须知道所有策略。
   - **应用场景**: 排序算法，支付系统中的多种支付方式。

10. **模板方法模式 (Template Method)**
    - **优点**: 提高代码复用性，灵活定义算法框架。
    - **缺点**: 每一个不同的实现都需要一个子类，增加类数量。
    - **应用场景**: 抽象类中定义通用方法，实现不同细节。

11. **访问者模式 (Visitor)**
    - **优点**: 增加新的操作方便，符合开闭原则。
    - **缺点**: 增加系统复杂性，访问者依赖具体元素。
    - **应用场景**: 编译器中的语法树操作，数据结构的遍历。

这些设计模式各有优势和劣势，在实际开发中选择合适的模式可以提高系统的灵活性和可维护性。