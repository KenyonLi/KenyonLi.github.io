import{_ as p,r as o,o as r,c as d,a as l,b as a,w as n,d as i,e as t}from"./app-c1c3c937.js";const h={},s=l("h2",{id:"目录",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#目录","aria-hidden":"true"},"#"),i(" 目录")],-1),c={class:"table-of-contents"},u=t(`<h2 id="存储高可用" tabindex="-1"><a class="header-anchor" href="#存储高可用" aria-hidden="true">#</a> 存储高可用</h2><h2 id="数据库可用文案-数据库高可用文案-redis-mysql-mongodb-consul-sqlserver" tabindex="-1"><a class="header-anchor" href="#数据库可用文案-数据库高可用文案-redis-mysql-mongodb-consul-sqlserver" aria-hidden="true">#</a> 数据库可用文案：数据库高可用文案： redis mysql mongodb consul,sqlserver</h2><p>Hbase Hadoop MongoDB Mysql-cluster</p><p>1、主备方案：数据量小，并发量小。 2、主从方案：数据量小，读并发里大，写并发量小。 3、主主方案：数据量小，读并发量小，写并发量大。 4、主从集群方案：数据量小，读并发量非常大，写并发量小。 5、集群分散方案：数据量大（大数库），读并发量大，写并发量大。</p><h2 id="数据分区高可用" tabindex="-1"><a class="header-anchor" href="#数据分区高可用" aria-hidden="true">#</a> 数据分区高可用</h2><ol><li>互相备份方案：数据量不大，经济上不富裕</li><li>集中式方案：数据量不大，经济富裕。</li><li>独立式方案：数据量非常（大数据）。经济非常富裕。</li></ol><h3 id="如何实现这些方案" tabindex="-1"><a class="header-anchor" href="#如何实现这些方案" aria-hidden="true">#</a> 如何实现这些方案</h3><ol><li>Mysql :Canal</li><li>SqlServer Oracel :DataX</li></ol><h2 id="计算高可用" tabindex="-1"><a class="header-anchor" href="#计算高可用" aria-hidden="true">#</a> 计算高可用</h2><p>1、计算高可用 计算：处理客户请求 无论什么情况下，都不会宕机 简单一句话：就是系统高可用。</p><p>对称计算。电商系统，所有实例都是相同的</p><h3 id="主备" tabindex="-1"><a class="header-anchor" href="#主备" aria-hidden="true">#</a> 主备</h3><p>数据并发量小只有一个实例</p><h3 id="主从" tabindex="-1"><a class="header-anchor" href="#主从" aria-hidden="true">#</a> 主从</h3><p>数据并发量小，有两个实例</p><h3 id="对称集群" tabindex="-1"><a class="header-anchor" href="#对称集群" aria-hidden="true">#</a> 对称集群</h3><p>数据并发量大，N个实现</p><h3 id="对称集群-伸缩-动态架构" tabindex="-1"><a class="header-anchor" href="#对称集群-伸缩-动态架构" aria-hidden="true">#</a> 对称集群 -伸缩/动态架构</h3><p>数据并发量小、大。N个实现</p><p>consul-Template</p><h3 id="非对称高可用" tabindex="-1"><a class="header-anchor" href="#非对称高可用" aria-hidden="true">#</a> 非对称高可用</h3><p>1、非对称计算：Nginx 系统计算不一样。不一样的客户请求 读并发量大，写并发量小</p><p>1、主从：写数据并发量小，读数据并发量小 2、非对称集群：写数据并发量小，读数据并发量大 3、非对称集群-动态架构：写数据并发量小，读数据并发量小、大。</p><p>任何系统中，数据。 扩展：</p><ol><li>如果写数据并发量大，读数据并发里大。</li><li>非对称集群-动态架构-分散集群</li></ol><p>总结： 1、 计算高可用</p><ol><li>对称计算高可用。实例处理客户端请求一样。</li><li>非对称计算高可用。实例处理客户端请求不一样。</li></ol><p>2、扩展方面</p><p>对称集群：不存储客户端数据的 非对称集群：存储客户端数据的</p><ol><li><p>redis集群 非对称</p></li><li><p>mongodb集群 非对称</p></li><li><p>nginx集群 对称</p></li><li><p>电商网系统 对称</p></li><li><p>docker集群 非对称</p></li><li><p>k8s 集群 非对称</p></li><li><p>如果nginx对称集群---电商系统架构思路一样</p></li><li><p>如果docker非对称集群----Mysql-Cluster</p></li><li><p>计算高可用</p></li><li><p>存储高可用</p></li><li><p>计算高性能</p></li><li><p>存储高性能</p></li></ol><h2 id="业务高可用" tabindex="-1"><a class="header-anchor" href="#业务高可用" aria-hidden="true">#</a> 业务高可用</h2><p>什么是业务高用 任何时候，保证业务能够正常访问</p><p>同城备份架构： 缺陷：时间延时，系统体验下降 1、业务操作实时性低：用户注册 行为</p><p>同城异区架构： 1、业务操作实时性强。用户登录 行为</p><p>跨城异地存在 总结 1、业务高可用，从系统整体角度思考 方案</p><ol><li>同城备份方案</li><li>同城异区方案</li><li>跨城异地方案</li><li>跨国方案</li></ol><p>1、从业务整体思考，业务系统高可用 2、业务接口角度思考，业务系统如何保证高可用？ 客户端并发，并发操作了业务系统的最高处理能力！</p><ol><li>业务系统宕机</li><li>业务不可用</li></ol><p>解决方案：限流</p><p>无论系统部署到任何地方，资源是有限的</p><ol><li><p>并发能力有限</p><p>单体限流：单体 增加限流模块 分布式限流：集群 nginx OpenResty 限流有一个局限</p><ol><li>直接过滤了所有请求，拒绝过滤的请求。</li></ol><p>换一个前提</p><ol><li>分布式系统。</li><li>资源有限。 进程内降级：将原有的系统变成不可访问 独立降级 总结：正常的系统变成不正常。目的腾出资源给核心系统使用。</li></ol><p>方案：熔断 .netcore polly ocelot ocelot.polly.</p><p>总结：</p><ol><li>单体系统：限流、排队</li><li>分布式系统：降级、熔断; 限流、排队（具体第一个分布系统高可用）</li></ol></li></ol><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>1、 业务全局角度</p><ol><li>同城备份方案</li><li>同城异区方案</li><li>跨城异地方案</li><li>跨国方案</li></ol><p>2、 业务接口角度</p><ol><li>单体系统：限流、排队</li><li>分布式系统：降级、熔断 限流、排队（具体每一个分布式系统高可用）</li></ol><h2 id="高扩展架构" tabindex="-1"><a class="header-anchor" href="#高扩展架构" aria-hidden="true">#</a> 高扩展架构</h2><p>什么是扩展，自定义操作：如果不修改原有系统。 扩展好处：适应不同的客户需求。 系统能够遵守开闭原则</p><p>什么是高扩展，原有系统不做任何改变 系统中任何模块，都能实现扩展。所有模块总数加起来，就是高扩展。</p><p>如何将架构做成高扩展</p><p>架构===属于系统 系统架构如何得到？ 拆分： 拆分好处：系统具备了扩展性。</p><ol><li>整体分解成部分。形成了架构，进一歩具备扩展性 怎么拆分？对谁拆分。系统。 对系统怎么拆分。<br> 系统：</li><li>流程：请求执行过程</li><li>模块：独立功能 + 数据</li><li>功能：业务逻辑</li></ol><h2 id="面向流程拆分" tabindex="-1"><a class="header-anchor" href="#面向流程拆分" aria-hidden="true">#</a> 面向流程拆分</h2><p>什么是流程 执行客户请求的过程 添加商品</p><ol><li>客户端---&gt; 商品逻辑处理---&gt; 商品数据处理---&gt; 存储到数据库</li></ol><p>公司为例子：</p><ol><li><p>老板是客户</p></li><li><p>员工是服务 用户--&gt; 老板--&gt; 管理--&gt;一线员工（可以无限递归） 客户端--&gt;电商网站--&gt;数据库</p></li><li><p>思想：客户+服务思想 业务（客户请求）流程（经历的过程）： 流程：根据每个角色独立拆分。</p></li></ol><p>::: 1. 业务流程拆分：全局架构，布局思想 1. 商品 2. 用户 3. 订单 4. 支付 2、 如何处理业务</p><ol><li><p>先具体：把所有业务都具体流程写处理</p></li><li><p>后抽象： 从具体相同流程中。抽象概念（抽象就是顶级架构）</p></li><li><p>再把概念拆分 :::</p></li><li><p>面向流程拆分的架构，叫做分层架构 分层架构： MVC分层架构：文件夹分层架构 只要你为别人服务，就会形成流程</p></li></ol><p>文件夹分层架构前提： 1、人少（1个人），系统模块多的时候 2、人少了（1个人），系统模块少的时候 架构意识----&gt;扩展 1、人多了，系统模块多的时候 业务模块（服务）拆分：微服务架构 面向功能拆分：插件架构（反射就可以实现）</p><p>当我们数量过多了，我们要归类，形成流程（归纳流程）。使用流程来分类</p><p>有流程存在，就用文件夹</p><p>总结</p><ol><li>面向流程</li><li>面向模块（服务）拆分</li><li>面向功能</li></ol><p>公司人多的时候，同时使用 公司人少： 项目使用文件夹分层。 系统模块少：使用，文件夹分层。 客户需求少，文件夹分层 系统模块更新频繁： 1. 客户需求多，修改原有系统 2. 客户端改变频繁</p><pre><code>解决方案：程序集拆分
1.程序集分层----文件夹分层架构来源

前提：客户端小。需求变化频繁
如果客户数量变多了，需求也变化频繁
程序集分层：DDD领域驱动,ABP


总结：
1. 文件夹分层架构。开发者角度，开发人少。业务模块数量，少/多的时候。客户数量少，客户需求量小
2. 微服务架构：开发者角度，开发人多，业务模块数量，少/多的时候。
3. 基础设施架构：开发者角度，开发人多，业务模块数量多，且通用功能少/多的时候
4. 程序集分层架构：使用者（客户端角度），客户数量少,客户需求量大的时候。
5. 程序集进一步分层---DDD：使用者（客户端角度），客户数量多（PC，App）,客户需求量大的时候
总结：纵向扩展
扩展
1、 从并发量角度思考：如果客户端并发量大，集群架构。横向扩容即可。项目数量增加。
总结：
1. 系统最终：纵向 + 横向  。纵横技术---纵横四海
前提：
1. 开发者：多和少
2. 使用者：多和少。大和小
3. 课程：难和易，好和不好

进一步：多和少。直觉，小和大。矛盾。
进一步：思想的本质：矛盾（阴阳）
毛主度：矛盾论

高薪就业：
1、天时：城市经济环境，起薪。
2、地利：企业经济环境。开薪水。
3、人和：人个技术实力
每一个人薪水待遇，薪水理念

高薪就业情况录取
高薪就业情况分析
高薪就业指导
</code></pre><p>1.城市:深圳 2.年龄:27 3.薪资:15K 4.学历:本科 5.专业:网络工程 6.毕业院校:桂林电子科技大学信息科技学院 7.工作经验:5年 8.短期诉求:18K以上薪资，使用技术较新 9.最近一次工作多长时间:1年</p>`,67);function f(_,b){const e=o("router-link");return r(),d("div",null,[s,l("nav",c,[l("ul",null,[l("li",null,[a(e,{to:"#目录"},{default:n(()=>[i("目录")]),_:1})]),l("li",null,[a(e,{to:"#存储高可用"},{default:n(()=>[i("存储高可用")]),_:1})]),l("li",null,[a(e,{to:"#数据库可用文案-数据库高可用文案-redis-mysql-mongodb-consul-sqlserver"},{default:n(()=>[i("数据库可用文案：数据库高可用文案： redis mysql mongodb consul,sqlserver")]),_:1})]),l("li",null,[a(e,{to:"#数据分区高可用"},{default:n(()=>[i("数据分区高可用")]),_:1}),l("ul",null,[l("li",null,[a(e,{to:"#如何实现这些方案"},{default:n(()=>[i("如何实现这些方案")]),_:1})])])]),l("li",null,[a(e,{to:"#计算高可用"},{default:n(()=>[i("计算高可用")]),_:1}),l("ul",null,[l("li",null,[a(e,{to:"#主备"},{default:n(()=>[i("主备")]),_:1})]),l("li",null,[a(e,{to:"#主从"},{default:n(()=>[i("主从")]),_:1})]),l("li",null,[a(e,{to:"#对称集群"},{default:n(()=>[i("对称集群")]),_:1})]),l("li",null,[a(e,{to:"#对称集群-伸缩-动态架构"},{default:n(()=>[i("对称集群 -伸缩/动态架构")]),_:1})]),l("li",null,[a(e,{to:"#非对称高可用"},{default:n(()=>[i("非对称高可用")]),_:1})])])]),l("li",null,[a(e,{to:"#业务高可用"},{default:n(()=>[i("业务高可用")]),_:1})]),l("li",null,[a(e,{to:"#总结"},{default:n(()=>[i("总结")]),_:1})]),l("li",null,[a(e,{to:"#高扩展架构"},{default:n(()=>[i("高扩展架构")]),_:1})]),l("li",null,[a(e,{to:"#面向流程拆分"},{default:n(()=>[i("面向流程拆分")]),_:1})])])]),u])}const g=p(h,[["render",f],["__file","design003.html.vue"]]);export{g as default};
