import{_ as h,r as d,o as r,c as i,a as e,b as t,w as l,d as a,e as s}from"./app-c1c3c937.js";const u={},c=e("h2",{id:"目录",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#目录","aria-hidden":"true"},"#"),a(" 目录")],-1),_={class:"table-of-contents"},p=e("h2",{id:"什么-大端-模式和-小端-模式",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#什么-大端-模式和-小端-模式","aria-hidden":"true"},"#"),a(" 什么“大端”模式和“小端”模式")],-1),f={href:"https://blog.csdn.net/yimuta9538/article/details/131108000",target:"_blank",rel:"noopener noreferrer"},x=s(`<p>计算机中的大端模式和小端模式是数据存储方式的两种不同表现形式。它们分别用于描述字节在内存中的排列方式，即如何存储多字节数据类型（例如整数、浮点数等）的字节序列。本文将详细介绍大端模式和小端模式的概念、区别、应用及其相关知识。</p><h2 id="一、概念" tabindex="-1"><a class="header-anchor" href="#一、概念" aria-hidden="true">#</a> 一、概念</h2><h3 id="_1-1-大端模式" tabindex="-1"><a class="header-anchor" href="#_1-1-大端模式" aria-hidden="true">#</a> 1.1 大端模式</h3><p>大端模式（Big-Endian）又称为网络字节序，指的是数据的高位字节存储在低地址处，而数据的低位字节存储在高地址处。这与我们平常的阅读顺序相同，先看到的是高位，后看到的是低位，因此被称为“大端”。<br> 例如，对于一个四字节整数0x12345678,在大端模式下，它的高字节是0x12,低位字节是0x78,它们在内存中的排列方式如下</p><p>+-----+-----+------+-----+ |12 | 34 | 56 | 78 | +-----+-----+------+-----+ addr3 addr2 addr1 addr0</p><h3 id="_1-2-小端模式" tabindex="-1"><a class="header-anchor" href="#_1-2-小端模式" aria-hidden="true">#</a> 1.2 小端模式</h3><p>小端模式（Little-Endian）指的是数据的低位字节存储在低地址处，而数据的高位字节存储在高地址处。这与我们平常的阅读顺序相反，先看到的是低位，后看到的是高位，因此被称为“小端”。 例如,对于一个四字节整数0x12345678,在小端模式下，它的高字节是0x78,低字节是0x12,它们在内存中的排列方式如下图所示：</p><p>+-----+-----+------+-----+ | 78 | 56 | 34 | 12 | +-----+-----+------+-----+ addr0 addr2 addr3 addr4</p><h2 id="二、区别" tabindex="-1"><a class="header-anchor" href="#二、区别" aria-hidden="true">#</a> 二、区别</h2><p>大端模式和小端模式的区别在于多字节数据类型在内存中的排列方式不同。具体而言，它们的区别主要表现在以下两个方面：</p><h3 id="_2-1-内存存储顺序" tabindex="-1"><a class="header-anchor" href="#_2-1-内存存储顺序" aria-hidden="true">#</a> 2.1 内存存储顺序</h3><p>在大端模式下，多字节数据类型的高位字节存储在低地址处，低位字节存储在高地址处；而在小端模式下，则恰好相反，多字节数据类型的低位处，高位字节存储在高地址处。</p><h3 id="_2-2-网络传输顺序" tabindex="-1"><a class="header-anchor" href="#_2-2-网络传输顺序" aria-hidden="true">#</a> 2.2 网络传输顺序</h3><p>在网络传输数据时，通常需要将数据转换成一定的字节序（即网络字节序），以确保在不同机器之间的传输中不会出现问题。因此，大多数协议规定了网络字节序采用大端模式。</p><h2 id="三、应用" tabindex="-1"><a class="header-anchor" href="#三、应用" aria-hidden="true">#</a> 三、应用</h2><p>大端模式和小端模式的应用主要小孩以下几个方面：</p><h3 id="_3-1-硬件架构" tabindex="-1"><a class="header-anchor" href="#_3-1-硬件架构" aria-hidden="true">#</a> 3.1 硬件架构</h3><p>不同的硬件架构（如：x86,ARM等）可能采用不同的字节方式。例如，Inte x86系统列处理器采用的是小端模式，而MIPS、PowerPC等处理器则采用的是大端模式。因此，在编写跨平台程序时，需要注意这些 差异，并进行相应的处理。</p><h3 id="_3-2-文件格式" tabindex="-1"><a class="header-anchor" href="#_3-2-文件格式" aria-hidden="true">#</a> 3.2 文件格式</h3><p>在文件格式中，常常需要使用待定的字节序来表示数据。例如，BMP图像文件中，像素数据通常采用小端模式存储；而WAV音频文件中，样本数据则用大端式中，样本数据则采用大端模式存储。</p><h3 id="_3-3-网络传输" tabindex="-1"><a class="header-anchor" href="#_3-3-网络传输" aria-hidden="true">#</a> 3.3 网络传输</h3><p>在网络传输数据时，通常需要将数据转换成网络字节序。例如，在TCP/IP协议中，采用的是端模式作为网络字节序。因此，在编写网络程序时，需要进行字节序转换以确保正确地传输数据。</p><h3 id="_3-4-数据库存储" tabindex="-1"><a class="header-anchor" href="#_3-4-数据库存储" aria-hidden="true">#</a> 3.4 数据库存储</h3><p>在数据库中，常常需要对多字节数据类型进行排序和比较。由于不同的字节方式会影响排序结果，因此在数据库设计中需要考虑字节序问题。</p><h2 id="四字节序转换" tabindex="-1"><a class="header-anchor" href="#四字节序转换" aria-hidden="true">#</a> 四字节序转换</h2><p>在实际编程中，需要将不同字节序的数据进行转换。常见的字节序换函数包括：</p><h3 id="_4-1-htons和ntohs" tabindex="-1"><a class="header-anchor" href="#_4-1-htons和ntohs" aria-hidden="true">#</a> 4.1 htons和ntohs</h3><p>htons(host to network short) 和 ntohs(network to host short) 用于将16位整数从主机字节序转换成网络字节或从网络字节序转换成主机字节序。</p><div class="language-C line-numbers-mode" data-ext="C"><pre class="language-C"><code>#include &lt;arpa/inet.h&gt;
uint16_t htons(uint16_t hostshort);
uint16_t ntohs(uint16_t netshort);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-2-htonl-host-to-network-long-和-ntohl-network-to-host-long-用于将32位整数从主机字位序转换成网络字节序或从网络字节序转换成主机字节序。" tabindex="-1"><a class="header-anchor" href="#_4-2-htonl-host-to-network-long-和-ntohl-network-to-host-long-用于将32位整数从主机字位序转换成网络字节序或从网络字节序转换成主机字节序。" aria-hidden="true">#</a> 4.2 htonl(host to network long) 和 ntohl(network to host long) 用于将32位整数从主机字位序转换成网络字节序或从网络字节序转换成主机字节序。</h3><div class="language-C line-numbers-mode" data-ext="C"><pre class="language-C"><code>#include &lt;arap/inet.h&gt;
uint32_t htonl(uint32_t hostlong);
uint32_t ntohl(uint32_t netlong);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些函数可以在不同平台上保证正确的字节序转换，并且在大数操作系统上都是已经实现。</p><h2 id="五-结论" tabindex="-1"><a class="header-anchor" href="#五-结论" aria-hidden="true">#</a> 五 结论</h2><p>本文介绍了计算机中的大端模式和小端模式，它们分别用于描述多字节数据类型在内存中的排列方式。大端模式和小端模式的区别在于字节的存储顺序不同，前者高位字节在低地址处，后者高位字节在高地址处。在实际应用中，大端模式和小端模式的应用主要涉及硬件架构、文件格式、网络传输和数据库存储等方面。为了确保数据在不同平台之间正确地传输和处理，需要进行字节序转换。常见的字节序转换函数包括htons、ntohs、htonl和ntohl等。</p>`,34);function b(g,v){const n=d("router-link"),o=d("ExternalLinkIcon");return r(),i("div",null,[c,e("nav",_,[e("ul",null,[e("li",null,[t(n,{to:"#目录"},{default:l(()=>[a("目录")]),_:1})]),e("li",null,[t(n,{to:"#什么-大端-模式和-小端-模式"},{default:l(()=>[a("什么“大端”模式和“小端”模式")]),_:1})]),e("li",null,[t(n,{to:"#一、概念"},{default:l(()=>[a("一、概念")]),_:1}),e("ul",null,[e("li",null,[t(n,{to:"#_1-1-大端模式"},{default:l(()=>[a("1.1 大端模式")]),_:1})]),e("li",null,[t(n,{to:"#_1-2-小端模式"},{default:l(()=>[a("1.2 小端模式")]),_:1})])])]),e("li",null,[t(n,{to:"#二、区别"},{default:l(()=>[a("二、区别")]),_:1}),e("ul",null,[e("li",null,[t(n,{to:"#_2-1-内存存储顺序"},{default:l(()=>[a("2.1 内存存储顺序")]),_:1})]),e("li",null,[t(n,{to:"#_2-2-网络传输顺序"},{default:l(()=>[a("2.2 网络传输顺序")]),_:1})])])]),e("li",null,[t(n,{to:"#三、应用"},{default:l(()=>[a("三、应用")]),_:1}),e("ul",null,[e("li",null,[t(n,{to:"#_3-1-硬件架构"},{default:l(()=>[a("3.1 硬件架构")]),_:1})]),e("li",null,[t(n,{to:"#_3-2-文件格式"},{default:l(()=>[a("3.2 文件格式")]),_:1})]),e("li",null,[t(n,{to:"#_3-3-网络传输"},{default:l(()=>[a("3.3 网络传输")]),_:1})]),e("li",null,[t(n,{to:"#_3-4-数据库存储"},{default:l(()=>[a("3.4 数据库存储")]),_:1})])])]),e("li",null,[t(n,{to:"#四字节序转换"},{default:l(()=>[a("四字节序转换")]),_:1}),e("ul",null,[e("li",null,[t(n,{to:"#_4-1-htons和ntohs"},{default:l(()=>[a("4.1 htons和ntohs")]),_:1})]),e("li",null,[t(n,{to:"#_4-2-htonl-host-to-network-long-和-ntohl-network-to-host-long-用于将32位整数从主机字位序转换成网络字节序或从网络字节序转换成主机字节序。"},{default:l(()=>[a("4.2 htonl(host to network long) 和 ntohl(network to host long) 用于将32位整数从主机字位序转换成网络字节序或从网络字节序转换成主机字节序。")]),_:1})])])]),e("li",null,[t(n,{to:"#五-结论"},{default:l(()=>[a("五 结论")]),_:1})])])]),p,e("p",null,[e("a",f,[a("参考地址"),t(o)])]),x])}const k=h(u,[["render",b],["__file","index.html.vue"]]);export{k as default};
